////////////////////////////////////////////////////////////////7 lesson////////////////////////////////////////////////////////////////////////////////////////////////////////////
//1 task
//...
let score = snake.length-3;
                document.getElementById('score').innerHTML = 'Ваш счет: '+score;
            } else { 
                if (tmp.className == 'cell snake'){
                    clearInterval(timer);

                    alert('Вы проиграли! Ваш счет: ' + (snake.length-3));
                }
            }
 

////////////////////////////////////////////////////////////////8 lesson////////////////////////////////////////////////////////////////////////////////////////////////////////////
//1 task Замыкания(вложенные функции) можно использовать при счете и выыводе score.т.к. переменная score сохраняет нужное значение между ее вызовами.
//2 task 

if (!("a" in window)) {
    var a = 1;                    //undefined.Т.к атрибута «a» в window нет, и ему неоткуда появится после if.
}                            
alert(a);



var b = function a(x) {
    x && a(--x);
};
alert(a);                           // undefined т.к. b = function a() { ...по имени «a» функция видна только здесь }


function a(x) {
    return x * 2;
}                                  //undefined т.к. var не переинициализирует переменную.
var a;
alert(a);


function b(x, y, a) {
    arguments[2] = 10;               //undefined т.к.  a и arguments[2] — это ссылка на одно и то же значение.
    alert(a);
}
b(1, 2, 3);



function a() {
    alert(this);              //undefined т.к.  this в глобальной области указывает на window. Вызов call() у функции с параметром null равнозначно вызову call() без аргументов,cледовательно вызываемая функция не сводится к  объекту .
a.call(null);
